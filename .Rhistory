mod_root <- gam(root ~ s(time))
mod_shoot <- gam(shoot ~ s(time))
resid_root <- avg(resid(mod_root))
resid_shoot <- avg(resid(mod_shoot))
out <- list(root = resid_root, shoot = resid_shoot)
return(out)
}
signals <- pre_process(raw_data)
signals
devtools(inclassnet)
devtools(https://github.com/AU-R-Programming/stat6210net.git)
devtools('https://github.com/AU-R-Programming/stat6210net.git')
library(devtools)
install_github("stat6210net")
devtools::document("stat6210net")
devtools::install_git("https://github.com/AU-R-Programming/stat6210net")
abalone <- read.csv2(file = 'abalone.csv') # It is better
setwd("~/GitHub/FinalProject_Group7")
abalone <- read.csv2(file = 'abalone.csv') # It is better
View(abalone)
abalone <- read.csv(file = 'abalone.csv') # It is better
View(abalone)
abalone <- read.csv(file = 'abalone.csv') # It is better
View(abalone)
abalone$Length
install.packages("fastDummies")
# Transform dummy variables
library(fastDummies)
View(abalone)
data <- dummy_cols(abalone, select_columns = "Sex")
abalone$Ã¯..Sex
abalone <- read.csv(file = 'abalone.csv')
View(abalone)
data <- dummy_cols(abalone, select_columns = "Sex")
View(data)
abalone[0:1, 1]
abalone[0:1, 3]
abalone[0:3, 3]
abalone[, 2:5]
View(abalone)
abalone <- dummy_cols(abalone, select_columns = "Sex")
View(abalone)
abalone[, 2:12]
y <- abalone$Rings
x <- abalone[, 2:11]
View(signals)
View(x)
drop(x$Rings)
# Import data
abalone <- read.csv(file = 'abalone.csv')
# Transform dummy variables
library(fastDummies)
abalone <- dummy_cols(abalone, select_columns = "Sex")
y <- abalone$Rings
x <- abalone[, 2:11]
x <- drop(x$Rings)
x <- abalone[, 2:11]
x2 <- drop(x$Rings)
x <- abalone[, 2:11]
x <- subset(x, select = -c("Rings"))
x <- subset(x, select = "Rings")
View(x)
x <- abalone[, 2:11]
x <- subset(x, select = -Rings)
View(x)
cov(y, x$Length)
x[0]
x[1]
x[2]
View(x)
x[1]
x[2]
x[2, 1]
x[2][1]
x[2]
x[1]
x[10]
x[9]
c(2)
c(1, 10)
c(seq(1, 10))
lapply(x, function(cov(y, x)))
lapply(x, cov(y, x))
matrix(, 1, 4)
initial_betas <- matrix(, 1, length(x) + 1)
for (i in 1:integer((length(x) + 1))) {
initial_betas[i] <- cov(y, x[i])
}
length(x)
length(x)+1
for (i in 1:length(x)+1) {
initial_betas[i] <- cov(y, x[i])
}
initial_betas <- matrix(, 1, length(x) + 1)
initial_betas
for (i in 1:numeric(length(x)+1)) {
initial_betas[i] <- cov(y, x[i])
}
for (i in 1:numeric(length(x)+1)) {
print(i)
initial_betas[i] <- cov(y, x[i])
}
1:numeric(length(x)+1)
for (i in 1:10) {
print(i)
initial_betas[i] <- cov(y, x[i])
}
initial_betas[1]
initial_betas[2]
initial_betas[3]
View(initial_betas)
for (i in 2:n_predictors+1) {
initial_betas[i] <- cov(y, x[i])
}
n_predictors <- length(x)
initial_betas <- matrix(, 1, n_predictors+1)
for (i in 2:n_predictors+1) {
initial_betas[i] <- cov(y, x[i])
}
for (i in 2:n_predictors+1) {
print(i)
initial_betas[i] <- cov(y, x[i])
}
initial_betas[1] <- mean(y)
for (i in 2:n_predictors+1) {
print(i)
initial_betas[i] <- cov(y, x[i])
}
initial_betas
length(x)
n_predictors <- length(x)
initial_betas <- matrix(, 1, n_predictors+1)
initial_betas[1] <- mean(y)
for (i in 2:n_predictors+1) {
print(i)
initial_betas[i] <- cov(y, x[i-1])
}
# Create initial solution
n_predictors <- length(x)
initial_betas <- matrix(, 1, n_predictors+1)
initial_betas[1] <- mean(y)
for (i in 2:n_predictors+1) {
initial_betas[i] <- cov(y, x[i-1])
}
View(initial_betas)
cov(y, x[2-1])
# Create initial solution
n_predictors <- length(x)
initial_betas <- matrix(, 1, n_predictors+1)
initial_betas[1] <- mean(y)
for (i in 2:n_predictors+1) {
initial_betas[i] <- cov(y, x[i-1])
}
View(initial_betas)
initial_betas[1] <- mean(y)
for (i in 2:n_predictors+1) {
print(i)
initial_betas[i] <- cov(y, x[i-1])
}
for (i in 1:n_predictors+1) {
print(i)
initial_betas[i] <- cov(y, x[i-1])
}
for (i in 1:3) {
print(i)
}
1:n_predictors
for (i in 1:number(n_predictors+1)) {
print(i)
initial_betas[i] <- cov(y, x[i-1])
}
for (i in 1:integer(n_predictors+1)) {
print(i)
initial_betas[i] <- cov(y, x[i-1])
}
for (i in 1:integer(n_predictors+1)) {
print(i)
}
for (i in 1:(n_predictors+1)) {
print(i)
initial_betas[i] <- cov(y, x[i-1])
}
for (i in 1:n_predictors) {
print(i)
initial_betas[i] <- cov(y, x[i-1])
}
for (i in 2:n_predictors) {
print(i)
initial_betas[i] <- cov(y, x[i-1])
}
initial_betas
n_predictors <- length(x)+1
initial_betas <- matrix(, 1, n_predictors)
initial_betas[1] <- mean(y)
# This for loop fill the initial solution
for (i in 2:n_predictors) {
print(i)
initial_betas[i] <- cov(y, x[i-1])/ var(x[i-1])
}
# Create initial solution
n_predictors <- length(x)+1
initial_betas <- matrix(, 1, n_predictors)
initial_betas[1] <- mean(y)
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[i-1])/ var(x[i-1])
}
initial_betas
cbind(1 = 1, x)
cbind('1' = 1, x)
x <- cbind('1' = 1, x)
n_predictors <- length(x)
initial_betas <- matrix(, 1, n_predictors)
initial_betas[1] <- mean(y)
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[i])/ var(x[i])
}
View(initial_betas)
t(y - x%*%initial_betas)
t(y - x%*%initial_betas)
t(y)
data.matrix(x)
t(y - data.matrix(x))
t(y - data.matrix(x[1:n_predictors]))
x[1:n_predictors]
y
t(c(1, 2, 3))
t(c(1, 2, 3) - c(1, 2, 3))
t(y - data.matrix(x[1:n_predictors]))
t(y - data.matrix(x[1:n_predictors]))[1]
t(y - data.matrix(x[1:n_predictors]))[2]
y[1]
data.matrix(x[1:n_predictors][1]
data.matrix(x[1:n_predictors][1])
data.matrix(x[1:n_predictors])[1]
data.matrix(x[1:n_predictors])
t(y - data.matrix(x[1:n_predictors]) %*% initial_betas)
t(y - data.matrix(x[1:n_predictors]) %*% data.matrix(initial_betas))
View(initial_betas)
View(signals)
View(x)
x2 <- data.matrix(x[1:n_predictors])
View(x2)
(y - data.matrix(x[1:n_predictors]) %*% data.matrix(initial_betas))
(y - (data.matrix(x[1:n_predictors]) %*% data.matrix(initial_betas)))
x[1:n_predictors] * x[1:n_predictors]
x[1:n_predictors] * initial_betas
(x[1:n_predictors] * initial_betas)[1]
(x[1:n_predictors] * t(initial_betas))[1]
(x[1:n_predictors] * t(initial_betas))
initial_betas
initial_betas <- c(, 1, n_predictors)
rep(NA, 0)
rep(NA, 3)
initial_betas <- rep(NA, n_predictors)
initial_betas[1] <- mean(y)
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[i])/ var(x[i])
}
initial_betas
(y - (data.matrix(x[1:n_predictors]) %*% initial_betas))
data.matrix(x[1:n_predictors]) %*% initial_betas)
(x[1:n_predictors] %*% initial_betas)
(data.matrix(x[1:n_predictors]) %*% initial_betas)
(y - (data.matrix(x[1:n_predictors]) %*% initial_betas))
t(y - (data.matrix(x[1:n_predictors]) %*% initial_betas))%*%(data.matrix(x[1:n_predictors]) %*% initial_betas)
## Here starts the package
x <- cbind('1' = 1, x)
x <- data.matrix(x)
n_predictors <- length(x)
initial_betas <- rep(NA, n_predictors)
initial_betas[1] <- mean(y)
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[i])/ var(x[i])
}
x
x[1]
x[1:2]
x[1:2, 1]
var(x[1])
x[1, 1]
x[1, 2]
x[1, 3]
View(x)
x <- abalone[, 2:11]
x <- subset(x, select = -Rings)
data.matrix(x)[1]
data.matrix(x)[1:2]
data.matrix(x)[1:2, 1]
data.matrix(x)[1:5, 1]
data.matrix(x)[1:, 1]
data.matrix(x)[:, 1]
data.matrix(x)[, 1]
# Create response variable and set of predictors
y <- abalone$Rings
x <- abalone[, 2:11]
x <- subset(x, select = -Rings)
## Here starts the package
x <- cbind('1' = 1, x)
x <- data.matrix(x)
n_predictors <- length(x)
initial_betas <- rep(NA, n_predictors)
initial_betas[1] <- mean(y)
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[,i])/ var(x[,i])
}
x[, 2]
n_predictors
col(x)
View(x)
ncol(x)
# Create response variable and set of predictors
y <- abalone$Rings
x <- abalone[, 2:11]
x <- subset(x, select = -Rings)
## Here starts the package
x <- cbind('1' = 1, x)
x <- data.matrix(x)
n_predictors <- ncol(x)
initial_betas <- rep(NA, n_predictors)
initial_betas[1] <- mean(y)
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[,i])/ var(x[,i])
}
initial_betas
t(y - (x %*% initial_betas))%*%(x %*% initial_betas)
sum(y - initial_betas)
y
sum(y - sum(initial_betas * x))
sum(initial_betas * x)
x
x[1]
x[,1]
initial_betas[1] * x[,1]
sum(initial_betas[1] * x[,1])
4177 * 9.93
sum(x[,1](y - sum(initial_betas * x)))
x[,1]
sum(x[,1] * (y - sum(initial_betas * x)))
length(x)
length(y)
n_obs <- length(y)
-2 * sum(x[,1] * (y - sum(initial_betas * x)))/length(x)/n_obs
initial_betas
initial_betas + 1
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
betas_update[i] <- initial_betas[i] + gradient_beta
}
betas_update
t(y - (x %*% initial_betas))%*%(x %*% initial_betas)
t(y - (x %*% betas_update))%*%(x %*% betas_update)
t(y - (x %*% initial_betas))%*%(y - x %*% initial_betas)
t(y - (x %*% betas_update))%*%(y - x %*% betas_update)
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
print(gradient_beta)
betas_update[i] <- initial_betas[i] + gradient_beta
}
learning_rate <- 0.001
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
print(gradient_beta)
betas_update[i] <- initial_betas[i] - learning_rate * gradient_beta
}
t(y - (x %*% betas_update))%*%(y - x %*% betas_update)
t(y - (x %*% initial_betas))%*%(y - x %*% initial_betas)
learning_rate <- 0.1
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
print(gradient_beta)
betas_update[i] <- initial_betas[i] - learning_rate * gradient_beta
}
t(y - (x %*% betas_update))%*%(y - x %*% betas_update)
error <- t(y - (x %*% initial_betas))%*%(y - x %*% initial_betas)
# Start gradient descent
learning_rate <- 0.1
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
print(gradient_beta)
betas_update[i] <- initial_betas[i] - learning_rate * gradient_beta
}
error_gradient <-  t(y - (x %*% betas_update))%*%(y - x %*% betas_update)
if (error_gradient < error) {
initial_betas <- betas_update
}
initial_betas
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
print(gradient_beta)
betas_update[i] <- initial_betas[i] - learning_rate * gradient_beta
}
error_gradient <-  t(y - (x %*% betas_update))%*%(y - x %*% betas_update)
error_gradient
learning_rate <- 0.1
for (it in 1:50) {
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
print(gradient_beta)
betas_update[i] <- initial_betas[i] - learning_rate * gradient_beta
}
error_gradient <-  t(y - (x %*% betas_update))%*%(y - x %*% betas_update)
if (error_gradient < error) {
initial_betas <- betas_update
}
}
learning_rate <- 0.1
for (it in 1:50) {
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
betas_update[i] <- initial_betas[i] - learning_rate * gradient_beta
}
error_gradient <-  t(y - (x %*% betas_update))%*%(y - x %*% betas_update)
if (error_gradient < error) {
initial_betas <- betas_update
error <- error_gradient
}
}
error
error_gradient
# Create response variable and set of predictors
y <- abalone$Rings
x <- abalone[, 2:11]
x <- subset(x, select = -Rings)
## Here starts the package
n_obs <- length(y)
x <- cbind('1' = 1, x) # create a column with ones
x <- data.matrix(x) # transform the previous column to a matrix
n_predictors <- ncol(x) # obtained the number of predictors plus the constant
initial_betas <- rep(NA, n_predictors) # vector to create the initial solution
initial_betas[1] <- mean(y) # fill the first element with the mean of the response
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[,i])/ var(x[,i])
}
# Create response variable and set of predictors
y <- abalone$Rings
x <- abalone[, 2:11]
x <- subset(x, select = -Rings)
## Here starts the package
n_obs <- length(y)
x <- cbind('1' = 1, x) # create a column with ones
x <- data.matrix(x) # transform the previous column to a matrix
n_predictors <- ncol(x) # obtained the number of predictors plus the constant
initial_betas <- rep(NA, n_predictors) # vector to create the initial solution
initial_betas[1] <- mean(y) # fill the first element with the mean of the response
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[,i])/ var(x[,i])
}
# Computing the error or loss function
error <- t(y - (x %*% initial_betas))%*%(y - x %*% initial_betas)
# Start gradient descent
learning_rate <- 0.1
for (it in 1:50) {
betas_update <- rep(NA, n_predictors)
for(i in 1:n_predictors){
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs
betas_update[i] <- initial_betas[i] - learning_rate * gradient_beta
}
error_gradient <-  t(y - (x %*% betas_update))%*%(y - x %*% betas_update)
if (error_gradient < error) {
initial_betas <- betas_update
error <- error_gradient
}
print(error)
}
# Create response variable and set of predictors
y <- abalone$Rings
x <- abalone[, 2:11]
x <- subset(x, select = -Rings)
## Here starts the package
n_obs <- length(y)
x <- cbind('1' = 1, x) # create a column with ones
x <- data.matrix(x) # transform the previous column to a matrix
n_predictors <- ncol(x) # obtained the number of predictors plus the constant
initial_betas <- rep(NA, n_predictors) # vector to create the initial solution
initial_betas[1] <- mean(y) # fill the first element with the mean of the response
# This for loop fill the initial solution
for (i in 2:n_predictors) {
initial_betas[i] <- cov(y, x[,i])/ var(x[,i])
}
# Computing the error or loss function
error <- t(y - (x %*% initial_betas))%*%(y - x %*% initial_betas)
# Start gradient descent
learning_rate <- 0.1
for (it in 1:50) { # This for loop repeats the algorithm
betas_update <- rep(NA, n_predictors) # initialize the betas for update
for(i in 1:n_predictors){ # This for loop gets the gradient for each beta
gradient_beta <- -2 * sum(x[,i] * (y - sum(initial_betas * x)))/length(x)/n_obs # This formula comes from gradient descent
betas_update[i] <- initial_betas[i] - learning_rate * gradient_beta # Update the ith beta
}
error_gradient <-  t(y - (x %*% betas_update))%*%(y - x %*% betas_update) # Compute the loss function
if (error_gradient < error) { # Evaluate if there is improvement
initial_betas <- betas_update
error <- error_gradient
}
print(error)
}
